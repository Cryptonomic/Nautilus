#!/bin/bash
#
# Master script to build and run conseil, postgres, and tezos containers and their respective volumes.
#
# DEFINE_SCRIPT_DIR([DIR])_DEFINE_SCRIPT_DIR([DIR],[cd "$(dirname "${BASH_SOURCE[0]}")" && pwd])
#
# ARG_OPTIONAL_INCREMENTAL([all],[a],[builds, links, and starts tezos, postgres, and conseil docker containers and their respective volumes])
# ARG_OPTIONAL_SINGLE([custom-build-path],[b],[specify a custom working directory to use for the build instance],[$HOME"/nautilus"])
# ARG_OPTIONAL_INCREMENTAL([conseil],[c],[stops and removes existing conseil container if it exists and rebuilds and starts a new instance of the conseil container])
# ARG_OPTIONAL_INCREMENTAL([database],[d],[stops and removes existing postgres database container if it exists and rebuilds only the postgres container])
# ARG_HELP([Connections to the imaging pi/instance/droplet are made using SSH.  Docker has to be preinstalled and ports 1337, 5432, 8732, 9732, and 19732 will be opened.\n \nThis script was written to be executed from Jenkins, but can also be run locally.\nIf executing from Jenkins, be sure to create a "jenkins" user on the remote imaging pi/instance/droplet and add the jenkins user public key as an authorized key.\nIf executing locally, be sure to change the postgres username and password in conseil.conf located in docker/config/local/conseil/ and use the same username and password in dockerfile for postgres.\n \nExamples:\nbash $CMD -a -p $HOME/production-environment-1\n# build, initialize, and run docker containers\n# for conseil, postgres, and tezos\n# takes config files from production-environment-1 folder\n])
# ARG_OPTIONAL_SINGLE([protocol],[n],[tezos network("mainnet", "zeronet", "alphanet").],["alphanet"])
# ARG_OPTIONAL_SINGLE([path-to-config],[p],[absolute path to configuration folder, folder should contain at the very least a conseil folder,\nif using a modified schema, a postgres folder with a conseil.sql file. if not specified,\nuses configuration files for conseil, postgres and tezos from the config folder in repo.\nConfig folder name will also be used in docker container nomenclature(e.g. config folder name is prod1, \ndocker container name will be conseil-prod1, postgres-prod1, etc.),\ndefault config folder is\"local\", it resides within config folder in repo\nNOTE: docker volumes will be created here to create persistence.],[$DIR"/config/local"])
# ARG_OPTIONAL_INCREMENTAL([tezos],[t],[stops and removes existing tezos container if it exists, rebuilds and starts the tezos container])
# ARG_OPTIONAL_BOOLEAN([volume],[v],[REMOVES postgres volume and postgres volume folder, use at own risk as this will \nrequire all blocks to be replaced in the postgres database, this is necessary if \nthere has been a schema change as simply rebuilding the container will not replace the schema])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([

# PLEASE TAKE CARE, this is not generated by the Argbash script but was added post-fact to add a var
# global constants
CMD="$(basename $0)"

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || die "Couldn't determine the script's running directory, which probably matters, bailing out" 2

### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


# # When called, the process ends.
# Args:
# 	$1: The exit message (print to stderr)
# 	$2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to $1)
# Example:
# 	test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}


# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option()
{
	local first_option all_short_options='abcdhnptv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_all=0
_arg_custom_build_path="$HOME"/nautilus""
_arg_conseil=0
_arg_database=0
_arg_protocol="alphanet"
_arg_path_to_config="$DIR"/config/local""
_arg_tezos=0
_arg_volume="off"


# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help()
{
	printf '%s\n' "Connections to the imaging pi/instance/droplet are made using SSH.  Docker has to be preinstalled and ports 1337, 5432, 8732, 9732, and 19732 will be opened.

This script was written to be executed from Jenkins, but can also be run locally.
If executing from Jenkins, be sure to create a \"jenkins\" user on the remote imaging pi/instance/droplet and add the jenkins user public key as an authorized key.
If executing locally, be sure to change the postgres username and password in conseil.conf located in docker/config/local/conseil/ and use the same username and password in dockerfile for postgres.

Examples:
bash $CMD -a -p $HOME/production-environment-1
# build, initialize, and run docker containers
# for conseil, postgres, and tezos
# takes config files from production-environment-1 folder
"
	printf 'Usage: %s [-a|--all] [-b|--custom-build-path <arg>] [-c|--conseil] [-d|--database] [-h|--help] [-n|--protocol <arg>] [-p|--path-to-config <arg>] [-t|--tezos] [-v|--(no-)volume]\n' "$0"
	printf '\t%s\n' "-a, --all: builds, links, and starts tezos, postgres, and conseil docker containers and their respective volumes"
	printf '\t%s\n' "-b, --custom-build-path: specify a custom working directory to use for the build instance (default: '$HOME"/nautilus"')"
	printf '\t%s\n' "-c, --conseil: stops and removes existing conseil container if it exists and rebuilds and starts a new instance of the conseil container"
	printf '\t%s\n' "-d, --database: stops and removes existing postgres database container if it exists and rebuilds only the postgres container"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-n, --protocol: tezos network(\"mainnet\", \"zeronet\", \"alphanet\"). (default: '"alphanet"')"
	printf '\t%s\n' "-p, --path-to-config: absolute path to configuration folder, folder should contain at the very least a conseil folder,
		if using a modified schema, a postgres folder with a conseil.sql file. if not specified,
		uses configuration files for conseil, postgres and tezos from the config folder in repo.
		Config folder name will also be used in docker container nomenclature(e.g. config folder name is prod1,
		docker container name will be conseil-prod1, postgres-prod1, etc.),
		default config folder is\"local\", it resides within config folder in repo
		NOTE: docker volumes will be created here to create persistence. (default: '$DIR/"config/local"')"
	printf '\t%s\n' "-t, --tezos: stops and removes existing tezos container if it exists, rebuilds and starts the tezos container"
	printf '\t%s\n' "-v, --volume, --no-volume: REMOVES postgres volume and postgres volume folder, use at own risk as this will
		require all blocks to be replaced in the postgres database, this is necessary if
		there has been a schema change as simply rebuilding the container will not replace the schema (off by default)"
}


# The parsing of the command-line
parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			# The all argurment doesn't accept a value,
			# we expect the --all or -a, so we watch for them.
			-a|--all)
				_arg_all=$((_arg_all + 1))
				;;
			# We support getopts-style short arguments clustering,
			# so as -a doesn't accept value, other short options may be appended to it, so we watch for -a*.
			# After stripping the leading -a from the argument, we have to make sure
			# that the first character that follows coresponds to a short option.
			-a*)
				_arg_all=$((_arg_all + 1))
				_next="${_key##-a}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-a" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# We support whitespace as a delimiter between option argument and its value.
			# Therefore, we expect the --custom-build-path or -b value.
			# so we watch for --custom-build-path and -b.
			# Since we know that we got the long or short option,
			# we just reach out for the next argument to get the value.
			-b|--custom-build-path)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_custom_build_path="$2"
				shift
				;;
			# We support the = as a delimiter between option argument and its value.
			# Therefore, we expect --custom-build-path=value, so we watch for --custom-build-path=*
			# For whatever we get, we strip '--custom-build-path=' using the ${var##--custom-build-path=} notation
			# to get the argument value
			--custom-build-path=*)
				_arg_custom_build_path="${_key##--custom-build-path=}"
				;;
			# We support getopts-style short arguments grouping,
			# so as -b accepts value, we allow it to be appended to it, so we watch for -b*
			# and we strip the leading -b from the argument string using the ${var##-b} notation.
			-b*)
				_arg_custom_build_path="${_key##-b}"
				;;
			# See the comment of option '--all' to see what's going on here - principle is the same.
			-c|--conseil)
				_arg_conseil=$((_arg_conseil + 1))
				;;
			# See the comment of option '-a' to see what's going on here - principle is the same.
			-c*)
				_arg_conseil=$((_arg_conseil + 1))
				_next="${_key##-c}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-c" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option '--all' to see what's going on here - principle is the same.
			-d|--database)
				_arg_database=$((_arg_database + 1))
				;;
			# See the comment of option '-a' to see what's going on here - principle is the same.
			-d*)
				_arg_database=$((_arg_database + 1))
				_next="${_key##-d}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option '--all' to see what's going on here - principle is the same.
			-h|--help)
				print_help
				exit 0
				;;
			# See the comment of option '-a' to see what's going on here - principle is the same.
			-h*)
				print_help
				exit 0
				;;
			# See the comment of option '--custom-build-path' to see what's going on here - principle is the same.
			-n|--protocol)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_protocol="$2"
				shift
				;;
			# See the comment of option '--custom-build-path=' to see what's going on here - principle is the same.
			--protocol=*)
				_arg_protocol="${_key##--protocol=}"
				;;
			# See the comment of option '-b' to see what's going on here - principle is the same.
			-n*)
				_arg_protocol="${_key##-n}"
				;;
			# See the comment of option '--custom-build-path' to see what's going on here - principle is the same.
			-p|--path-to-config)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_path_to_config="$2"
				shift
				;;
			# See the comment of option '--custom-build-path=' to see what's going on here - principle is the same.
			--path-to-config=*)
				_arg_path_to_config="${_key##--path-to-config=}"
				;;
			# See the comment of option '-b' to see what's going on here - principle is the same.
			-p*)
				_arg_path_to_config="${_key##-p}"
				;;
			# See the comment of option '--all' to see what's going on here - principle is the same.
			-t|--tezos)
				_arg_tezos=$((_arg_tezos + 1))
				;;
			# See the comment of option '-a' to see what's going on here - principle is the same.
			-t*)
				_arg_tezos=$((_arg_tezos + 1))
				_next="${_key##-t}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-t" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			# See the comment of option '--all' to see what's going on here - principle is the same.
			-v|--no-volume|--volume)
				_arg_volume="on"
				test "${1:0:5}" = "--no-" && _arg_volume="off"
				;;
			# See the comment of option '-a' to see what's going on here - principle is the same.
			-v*)
				_arg_volume="on"
				_next="${_key##-v}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


#echo "Value of --all: $_arg_all"
#echo "conseil is $_arg_conseil"
#echo "database is $_arg_database"
#echo "tezos is $_arg_tezos"
#echo "protocol is $_arg_protocol"
#echo "volume is $_arg_volume"
#echo "Using build path: $_arg_custom_build_path"
#echo "config path is $_arg_path_to_config"

# utility functions used by this script
error () { echo "error: $@" >&2; }
fatal () { echo "fatal: $@" >&2; exit 1; }

# set execution flags and/or execute functions for each option

if [[ $_arg_all > 0 ]]; then
        CONSEIL=1
        POSTGRES=1 
        TEZOS=1
fi
if [[ $_arg_conseil -ne 0 ]]; then CONSEIL=1; fi
if [[ $_arg_database -ne 0 ]]; then POSTGRES=1; fi
if [[ $_arg_tezos -ne 0 ]]; then TEZOS=1; fi
if [[ "$_arg_volume" == "on" ]]; then VOLUME=1; fi
BUILD_NAME=$_arg_custom_build_path

echo "Using build path: $_arg_custom_build_path"

echo "Configurations stored in $_arg_path_to_config"

# ensure necessary command line parameters were specified(man test to see usages, checks contents of a string)
[[ -z "${CONSEIL}${POSTGRES}${TEZOS}${VOLUME}" ]] && print_help \
    && fatal "Please specify at least one container type (examples: -a,-c,-d,-t)."

# ensure that mutually exclusive options are not passed in
[[ -n "${CONSEIL}${POSTGRES}${TEZOS}" ]] \
  && [[ -n "${VOLUME}" ]] \
  && fatal "Please choose only container flags or the volume flag, but not both"

build_time=$(date "+%Y.%m.%d-%H.%M.%S")

#working directory

[[ -d "$BUILD_NAME" ]] || mkdir "$BUILD_NAME"
WORKING_DIR="$BUILD_NAME"/"$build_time"
#example: production-environment-1, will default to base folder name of config files
DEPLOYMENT_ENV="$(basename "$_arg_path_to_config")"

#make working directory
[[ -d "$WORKING_DIR" ]] || mkdir "$WORKING_DIR"
(( $? == 0 )) || fatal "Unable to create working directory."


NAUTILUS_NETWORK=`docker network ls | grep nautilus`
[[ -z "${NAUTILUS_NETWORK}" ]] && docker network create nautilus
. "$DIR"/app/conseil/build_conseil.sh
. "$DIR"/app/postgres/build_postgres.sh
. "$DIR"/app/tezos/build_tezos.sh



remove_postgres_all () {
    docker container stop postgres-"$DEPLOYMENT_ENV"
    docker container rm postgres-"$DEPLOYMENT_ENV"
    docker volume rm pgdata-"$DEPLOYMENT_ENV"
    VOLUME_DIR=$HOME/volumes/pgdata-"$DEPLOYMENT_ENV"
    rm -rf "$VOLUME_DIR"
}




#if postgres-volume flag remove postgres volumes
[[ "$VOLUME" ]] && remove_postgres_all

#if tezos flag set build tezos container
[[ "$TEZOS" ]] && build_tezos "$DEPLOYMENT_ENV" "$WORKING_DIR" "$_arg_path_to_config" "$build_time"

#if postgres flag set build postgres container
[[ "$POSTGRES" ]] && build_postgres "$DEPLOYMENT_ENV" "$WORKING_DIR" "$_arg_path_to_config" "$build_time"

#if conseil flag set build conseil container
[[ "$CONSEIL" ]] && build_conseil "$DEPLOYMENT_ENV" "$WORKING_DIR" "$_arg_path_to_config" "$build_time"

#tezos network protocol flag set check
#[[ $tezosprotocol ]] && set_protocol

exit 0
# ] <-- needed because of Argbash

